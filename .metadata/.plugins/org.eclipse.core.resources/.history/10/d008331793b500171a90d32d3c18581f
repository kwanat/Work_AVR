// Created by: KAMIL WANAT
// uC: Attiny 24
// dostêpne porty: PA0-7, PB0-3
// port przycisku: PB0
// porty wyjsciowe: PA0-7

#include <avr/io.h>
#include<avr/interrupt.h>
# include <util/delay.h>

//makra uzytkownika
#define il_migniec 8
#define czas_migniecia 40
#define czas_calosci 18

//makra sprzetowe
#define LED1 (1<<PD0)
#define LED2 (1<<PD1)
#define LED3 (1<<PD2)
#define LED4 (1<<PD3)
#define LED5 (1<<PD4)
#define LED6 (1<<PD5)



#define music (1<<PB1)
#define KEY (1<<PB0)
#define PORTLED PORTD
#define DDRLED DDRD

#define PINKEY PINB
#define PORTKEY PORTB


uint8_t d1;
uint8_t d2;
uint8_t d3;
uint8_t d4;
uint8_t d5;
uint8_t d6;
int t_counter0 = 0;
uint8_t t_counter1 = 0;
uint8_t t_counter2 = 0;
uint8_t p_counter = 0;

//progi PWM
#define prog_0 230
#define prog_1 205
#define prog_2 180
#define prog_3 155
#define prog_4 130
#define prog_5 105
#define prog_6 80
#define prog_7 55
#define prog_8 30
#define prog_9 15



char pwm1 = 255; //zaczynamy od PWM z duty cycle = 0
char pwm2 =255;
char w_gore = 1; //
uint8_t currentpwm=1;
char LED_przelicz_jasnosc(char wartosc){

 //funkcja koryguj¹ca jasnoœæ œwiecenia, wartoœci dobrane doœwiadczalnie

 if(wartosc > prog_0) {
  return 255;
 }else if(wartosc > prog_1) {
  return 128;
 }else if(wartosc > prog_2) {
  return 80;
 }else if(wartosc > prog_3) {
  return 60;
 }else if(wartosc > prog_4) {
  return 50;
 }else if(wartosc > prog_5) {
  return 35;
 }else if(wartosc > prog_6) {
  return 20;
 }else if(wartosc > prog_7) {
  return 10;
 }else if(wartosc > prog_8) {
  return 6;
 }else if(wartosc > prog_9) {
  return 3;
 }else{
  return 0;
 }
}

void timer_init();
void start_timer();
void stop_timer();
void PWM_init();
void PWM_led();
char LED_przelicz_jasnosc(char wartosc);

int main(void) {
	PWM_init();
	timer_init();
	uint8_t key_lock;
	DDRLED = 0xFF;
//	DDRLED1 |= music;
	PORTKEY |= KEY;

	sei();
	while (1) {

		_delay_ms(20);
		PWM1_led(&OCR1A,1);
		PWM1_led(&OCR1B,-1);
		/*

		if (!key_lock && !(PINKEY & KEY)) {
			PORTLED1 ^= music;
			_delay_ms(50);
			PORTLED1 ^= music;

			start_timer();
			key_lock = 1;
			//reakcja na wcisniecie klawisza
		} else if (key_lock && (PINKEY & KEY))
			key_lock++;
*/
	}
	return 0;
}

void PWM_init()
{
	DDRB= (1<<PB2) | (1<<PB1); //LEDY podpiête pod: PB2-LED lewy, PB1-LED prawy

	 //PWM Mode 5 - Fast PWM, 8-bit
	 //piny OC1A i OC1B ustawiane na Compare Match, kasowane przy BOTTOM czyli
	 //Set OC1A/OC1B on Compare Match, clear OC1A/OC1B at BOTTOM, (inverting mode)
	 TCCR1A = (1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)/*| (1<<WGM13)| (1<<WGM12)| (1<<WGM11) */| (1<<WGM10);

	 TCCR1B = (1<<CS11); //preskaler = 256
	 OCR1A=255;
	 OCR1B=255;
}


void timer_init() {

	TCCR0 |= (1<<CS00)|(1<<CS02); //1024 bit prescaler
	TIMSK |= (1<<TOIE0);

}

void start_timer() {
	TCCR0 |= (1 << CS00) | (1 << CS02);
}

void stop_timer() {
	TCCR0 &= (!(1 << CS00)) & (!(1 << CS02));
}

void PWM1_led(volatile uint8_t *PWMregister, uint8_t pwmnumber)
{
	if(currentpwm==pwmnumber){
	 if(w_gore) {

	   //rozjaœnianie LED

	   if(pwm1>5){
	    pwm1 -= 5;
	    }else{
	    //osi¹gniêto górn¹ granicê
	    pwm1 = 0;
	    w_gore = 0;  // zmieñ kierunek

	   }

	  }else{

	   //œciemnianie LED

	   if(pwm1<250){
	    pwm1 += 5;

	   }else{
	    //osi¹gniêto doln¹ granicê
	    pwm1 = 255;
	    w_gore = 1;  // zmieñ kierunek
	    currentpwm*=-1;
	   }
	  }

	 	*PWMregister = pwm1;
	   //OCR1A = LED_przelicz_jasnosc(pwm1);
	   //OCR1B = LED_przelicz_jasnosc(pwm2);//ustaw PWM LED prawy bez korekcji
	}
}

ISR (TIMER0_OVF_vect) {
	//PORTLED ^=LED1;

	t_counter0++;
	t_counter1++;
	t_counter2++;

	if(t_counter0==0)
		PORTLED^=LED1;
	if(t_counter0==200)
		PORTLED^=LED2;
	if(t_counter0==400)
		PORTLED^=LED3;
	if(t_counter0==600)
		PORTLED^=LED4;
	if(t_counter0==800)
		PORTLED^=LED5;
	if(t_counter0==1000)
		PORTLED^=LED6;
	if(t_counter0==1200)
		t_counter0=0;








	if ((t_counter0 > 0) && (t_counter0 < 9)) {

		PORTLED ^= LED1;
	}
	if ((t_counter0 > 8) && (t_counter0 < 17)) {
		PORTLED ^= LED2;
		if (t_counter0 >= 16)
			t_counter0 = 0;
	}

	if ((t_counter1 > 2) && (t_counter1 < 11)) {
		PORTLED ^= LED3;
	}
	if ((t_counter1 > 10) && (t_counter1 < 19)) {
		PORTLED ^= LED4;
		if (t_counter1 >= 18)
			t_counter1 = 2;
	}

	if ((t_counter2 > 4) && (t_counter2 < 13)) {
		PORTLED ^= LED5;
	}
	if ((t_counter2 > 12) && (t_counter2 < 21)) {
		PORTLED ^= LED6;
		if (t_counter2 >= 20) {
			t_counter2 = 4;
			p_counter++;
		}
	}
	if (p_counter >= czas_calosci) {
		stop_timer();
		p_counter = 0;
	}
}


